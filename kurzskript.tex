\documentclass{scrreprt}

\usepackage[ngerman]{babel} 
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{color}
\usepackage{longtable}

\begin{document}
\title{Theoretische Informatik {\uppercase\expandafter{\romannumeral1}}:\\Komplexität und formale Sprachen}
\subtitle{Kurzskript zur Vorlesung von Van Bang Le}

\maketitle
\tableofcontents

\newtheorem{Definition}{Definition}[section]
\newtheorem{Satz}{Satz}[section]
\newtheorem{Lemma}{Lemma}[section]
\newtheorem{Beispiel}{Beispiel}[section]


\setcounter{chapter}{-1}
\chapter{Wichtige Begriffe aus der Berechenbarkeitstheorie}
\textbf{Kernfrage: Ist ein Problem algorithmisch lösbar?}

\begin{Definition}[Turingmaschine]
Eine \textcolor{blue}{deterministische Turingmaschine} (DTM) (oder ein det. Turingprogramm) $M$ ist ein 5-Tupel $M=(Z,\Sigma,\delta,z_a,z_e)$ mit:
\begin{itemize}
\item $Z$ ist eine endliche Menge von Zuständen
\item $z_a$ ist der ausgezeichnete Anfangszustand
\item $z_e$ ist der ausgezeichnete Endzustand
\item $\Sigma$ ist eine endliche Menge, das \textcolor{blue}{Bandalphabet}\\
$\Box$ ist ein ausgezeichnetes Symbol in $\Sigma$: es heißt \textcolor{blue}{Leersymbol} (Blank) und zeigt an, dass die Bandzelle leer ist
\item $Z \cap \Sigma = \emptyset$
\item $\delta : Z \times \Sigma \rightarrow Z \times \Sigma \times \{+1,-1,0\}$ ist eine nicht notwendig überall definierte Funktion, die \textcolor{blue}{Übergangsfunktion} 
\end{itemize}
\end{Definition}

\begin{Definition}[Turing-berechenbar]
Eine (partielle) Funktion $f: \Sigma^* \rightarrow \Sigma^*$ heißt \textcolor{blue}{Turingprogramm-berechenbar}, falls eine DTM $M$ existiert mit $f=f_M$.
\end{Definition}

\begin{Definition}[Entscheidbarkeit]
Eine Menge $A\subseteq \mathbb{N}$ (bzw. $A\subseteq \mathbb{N}^k$ oder $A\subseteq \Sigma^*$) heißt \textcolor{blue}{entscheidbar}, wenn die charakteristische Funktion $\chi_A : \mathbb{N} \rightarrow \{0,1\}$ (bzw. $\chi_A : \mathbb{N}^k \rightarrow \{0,1\}$ oder $\chi_A : \Sigma^* \rightarrow \{0,1\}$) von $A$,
\begin{flalign*}
\chi_A(x) =
\begin{cases}
1&\text{falls $x\in A$}\\
0&\text{sonst, also falls $x\in A$}\\
\end{cases}
\end{flalign*}
berechenbar ist.
\end{Definition}

\chapter{Komplexität}

\textbf{Kernfrage: Wie schwierig ist ein lösbares Problem?}
\section{Graphen}
\begin{Definition}
Ein (ungerichteter, einfacher) Graph $G$ ist ein Paar $G=(V,E)$ bestehend aus \textcolor{blue}{Knotenmenge} $V$ und \textcolor{blue}{Kantenmenge} $E\subseteq \binom{V}{2}$.\\
$\binom{V}{2}$ steht hierbei für die Menge aller 2-elementigen Teilmengen von $V$.
\end{Definition}
\begin{Definition}
Sei $G=(V,E)$ ein Graph. Dann gilt:
\begin{enumerate}
\item Zwei Knoten $x,y \in V$ sind \textcolor{blue}{verbunden}, wenn $\{x,y\} \in E$ ist.
\item Eine Menge $Q \subseteq V$ von Knoten ist eine \textcolor{blue}{Clique}, wenn je zwei Knoten in $Q$ verbunden sind.
\item Eine Menge $U \subseteq V$ von Knoten ist eine \textcolor{blue}{unabhängige Menge} (independent set), wenn je zwei Knoten in $U$ unverbunden sind.
\end{enumerate}
\end{Definition}

\section{Zeitaufwand und Komplexitätsklassen}
\begin{Definition}[$\mathcal{O}$-Notation]
Für Funktionen $f, g: \mathbb{N} \rightarrow \mathbb{R}$ schreiben wir \textcolor{blue}{$f \in \mathcal{O}(g)$} oder auch \textcolor{blue}{$f=\mathcal{O}(g)$}, falls es eine Konstante $c>0$ gibt mit: Es existiert ein $n_0$, sodass $f(n) \leq c \cdot g(n)$ für alle $n\geq n_0$ gilt. Man sagt, dass $f$ asymptotisch höchstens so stark wächst wie $g$.\\
Formal: $f \in \mathcal{O}(g) \Leftrightarrow \exists c>0 \, \exists n_0 \in \mathbb{N}\, \forall n\geq n_0:f(n)\leq c \cdot g(n)$
\end{Definition}

\begin{Definition}[Zeitaufwand von DTM-Programmen]
Sei $M$ eine DTM über dem Alphabet $\Sigma$. Der \textcolor{blue}{Zeitaufwand} $t_M(w)$ von $M$ bei Eingabe $w \in \Sigma^*$ ist
\begin{flalign*}
t_M(w)=
\begin{cases}
\parbox[t]{0.5\textwidth}{Zahl der Konfigurationsübergänge der Berechnung von $M$ bei Eingabe $w$}&\text{falls Berechnung abbricht}\\
\infty&\text{sonst}\\
\end{cases}&&
\end{flalign*}
Der \textcolor{blue}{Zeitaufwand} $t_M(n)$ von $M$ bei Eingaben der Codierungslänge $n$ ist\\
$t_M(n)=\max \{t_M(w)|w\in\Sigma^n\}$
\end{Definition}

\begin{Definition}
Es sei $f : \mathbb{N} \rightarrow \mathbb{N}$ eine Funktion. Mit \textcolor{blue}{\textsf{DTIME($f$)}} bezeichnen wir die Menge aller Entscheidungsprobleme, die sich durch eine DTM $M$ mit Zeitaufwand $t_m = O(f)$ entscheiden lassen:\\
$\textcolor{blue}{\textsf{DTIME(f)}}=\{L\subseteq \Sigma^* \mid \text{$L$ ist entscheidbar durch eine DTM $M$ mit $t_m=\mathcal{O}(f)$} \}$
\end{Definition}

\begin{Definition}[Komplexitätsklasse \textsf{P}]
$\textsf{P} = \bigcup\limits_{k=0}^\infty \textsf{DTIME}(n^k)$ ist die Klasse aller in (deterministisch) \textbf{p}olynomiellem Zeitaufwand lösbaren (Entscheidungs-) Probleme.  \textsf{P} ist also die Klasse von Problemen, die effizient gelöst werden können.
\end{Definition}

\begin{Definition}[Komplexitätsklasse \textsf{EXPTIME}]
$\textsf{EXPTIME} = \bigcup\limits_{k=0}^\infty \textsf{DTIME}(2^{n^k})$ ist die Klasse aller in (deterministisch) exponentiellem Zeitaufwand lösbaren (Entscheidungs-) Probleme. (Es gilt: $\textsf{P}\subseteq \textsf{EXPTIME}$)
\end{Definition}

\begin{Definition}[Nichtdeterministische Turingmaschine]
Eine \textcolor{blue}{nichtdeterministische Turingmaschine} (NTM) (oder ein nichtdet. Turingprogramm) $M$ ist ein 5-Tupel $M=(Z,\Sigma,\delta,z_a,z_e)$ mit:
\begin{itemize}
\item $Z$,$z_a$,$z_e$,$\Sigma$ sind definiert wie bei einer deterministischen Turingmaschine
\item $\delta \subseteq (Z \times \Sigma) \times (Z \times \Sigma \times \{+1,-1,0\})$ ist eine \textcolor{red}{Relation}, die \textcolor{blue}{Übergangsrelation} 
\end{itemize}
In einem nichtdeterministischen Turingprogramm $\delta$ kann es zu einem Paar $(z,x)\in Z \times \Sigma$ mehr als einen Befehl mit der linken Seite $z,x$ geben.
\end{Definition}

\begin{Definition}[Nichtdeterministische Berechnung]
Jedem Eingabewort $w\in \Sigma^*$ kann man einen \glqq Berechnungsbaum \grqq zuordnen, dessen maximale Pfade den möglichen Berechnungen entsprechen:
\begin{itemize}
\item Die Wurzel des Berechnungsbaums ist mit der Anfangskonfiguration $z_a w$ beschriftet
\item Ist $v$ ein Knoten des Baums, der mit der Konfiguration $K = \alpha zx \beta$ markiert ist und ist $\delta(z,x) = \{ (z_1,x_1,\lambda_1),\ldots,(z_r,x_r,\lambda_r)\}$, so hat $v$ genau $r$ Söhne, die jeweils mit den Nachfolgekonfigurationen $K_i$ von $K$ bezüglich $(z_i,x_i,\lambda_i)$ beschriftet sind, $i=1,\ldots,r$.
\end{itemize}
\end{Definition}

\begin{Definition}[Nichtdeterministische Entscheidbarkeit]
Eine NTM $M$ entscheidet die Menge $L\subseteq \Sigma^*$, falls der Berechnungsbaum jedes Eingabewortes $w\in \Sigma^*$ endlich ist und für $w\in L$ mindestens einen erfolgreichen Berechnungspfad enthält.
\end{Definition}

\begin{Satz}
Sei $L\subseteq \Sigma^*$. Dann ist $L$ genau dann (deterministisch) entscheidbar, wenn $L$ nichtdeterministisch entscheidbar ist.
\end{Satz}

\begin{Definition}[Zeitaufwand von NTM-Programmen]
Sei $M$ eine NTM über dem Alphabet $\Sigma$. Der \textcolor{blue}{Zeitaufwand} $t_M(w)$ von $M$ bei Eingabe $w \in \Sigma^*$ ist
\begin{flalign*}
t_M(w)=
\begin{cases}
\parbox[t]{0.5\textwidth}{Tiefe des Berechnungsbaumes von $M$ bei Eingabe $w$}&\text{falls Baum endlich}\\
\infty&\text{sonst}\\
\end{cases}&&
\end{flalign*}
Der \textcolor{blue}{Zeitaufwand} $t_M(n)$ von $M$ bei Eingaben der Codierungslänge $n$ ist\\
$t_M(n)=\max \{t_M(w)|w\in\Sigma^n\}$
\end{Definition}

\begin{Definition}
Es sei $f : \mathbb{N} \rightarrow \mathbb{N}$ eine Funktion. Mit \textcolor{blue}{\textsf{NTIME($f$)}} bezeichnen wir die Menge aller Entscheidungsprobleme, die sich durch eine NTM $M$ mit Zeitaufwand $t_m = O(f)$ entscheiden lassen:\\
$\textcolor{blue}{\textsf{NTIME(f)}}=\{L\subseteq \Sigma^* \mid \text{$L$ ist entscheidbar durch eine NTM $M$ mit $t_m=\mathcal{O}(f)$} \}$
\end{Definition}

\begin{Definition}[Komplexitätsklasse \textsf{NP}]
$\textsf{NP} = \bigcup\limits_{k=0}^\infty \textsf{NTIME}(n^k)$ ist die Klasse aller in \textbf{n}ichtdeterministisch \textbf{p}olynomiellem Zeitaufwand lösbaren (Entscheidungs-) Probleme.
\end{Definition}

\begin{Satz}
$\textsf{P}\subseteq \textsf{NP} \subseteq \textsf{EXPTIME}$
\end{Satz}

\section{Polynomielle Reduktion und \textsf{NP}-Vollständigkeit}
\begin{Definition}[Polynomielle Reduktion]
Seien $L_1 \subseteq \Sigma_1^*$, $L_2 \subseteq \Sigma_2^*$ zwei Entscheidungsprobleme. $L_1$ ist auf $L_2$ \textcolor{blue}{polynomiell reduzierbar}, wenn es eine überall definierte, polynomiell berechenbare Funktion $f:\Sigma_1^* \rightarrow \Sigma_2^*$ gibt, so dass für alle $x\in\Sigma_1^*$ gilt:
\begin{equation*}
x\in L_1 \Leftrightarrow f(x) \in L_2
\end{equation*}
Ist $L_1$ polynomiell reduzierbar auf $L_2$ via $f$, so schreiben wir: $L_1 \leq_p L_2$
\end{Definition}

\begin{Definition}[\textsf{NP}-Vollständigkeit]
Es sei $L\subseteq\Sigma^*$. $L$ heißt \textcolor{blue}{\textsf{NP}-vollständig}, falls gilt:
\begin{enumerate}
\item[(i)] $L\in \textsf{NP}$
\item[(ii)] $\forall M\in\textsf{NP}: M\leq_p L$
\end{enumerate}
\end{Definition}
\begin{Lemma}
Ist $L$ \textsf{NP}-vollständig, so gilt: $\L \in \textsf{P} \Leftrightarrow \textsf{P} = \textsf{NP}$
\end{Lemma}
\begin{Satz}[Satz von Cook und Levin]
\textsf{SAT} ist \textsf{NP}-vollständig.
\end{Satz}
\begin{Satz}
Ist $A$ $\textsf{NP}$-vollständig, $A \leq_p B$ und $B \in \textsf{NP}$, so ist $B$ $\textsf{NP}$-vollständig.
\end{Satz}

\begin{Satz}
$\textsf{3-SAT}$ ist $\textsf{NP}$-vollständig.
\end{Satz}

\begin{Satz}
$\textsf{CLIQUE}$ ist $\textsf{NP}$-vollständig.
\end{Satz}

\begin{Satz}
$\textsf{INDSET}$ und $\textsf{VERTEX COVER}$ sind $\textsf{NP}$-vollständig.
\end{Satz}

\begin{Satz}
$\textsf{3-Färbbarkeit}$ ist $\textsf{NP}$-vollständig.
\end{Satz}

\begin{Satz}
$\textsf{SUBSET-SUM}$ ist $\textsf{NP}$-vollständig.
\end{Satz}

\begin{Definition}[Komplexitätsklasse \textsf{coK}]
Sei $\textsf{K}$ eine Komplexitätsklasse über dem Alphabet $\Sigma$. Dann heißt
\begin{equation*}
\textsf{coK} :=\{L\subseteq\Sigma^* \mid \overline{L} \in K\}
\end{equation*}
die Klasse der Sprachen (Entscheidungsprobleme) $L$, deren Komplement $\overline{L}$ in $K$ liegt.
\end{Definition}

\begin{Satz}
$\textsf{coP} = \textsf{P}$
\end{Satz}

\section{Platzkomplexität}
\begin{Definition}[Speicherbedarf von DTM-Programmen]
Sei $M$ eine DTM über dem Alphabet $\Sigma$. Der \textcolor{blue}{Speicherbedarf} $s_M(w)$ von $M$ bei Eingabe $w \in \Sigma^*$ ist
\begin{flalign*}
s_M(w)=
\begin{cases}
\parbox[t]{0.5\textwidth}{Zahl der Bandzellen, die $M$ bei Bearbeitung von Eingabe $w$ besucht}&\text{falls Berechnung abbricht}\\
\infty&\text{sonst}\\
\end{cases}&&
\end{flalign*}
Der \textcolor{blue}{Speicherbedarf} $s_M(n)$ von $M$ bei Eingaben der Codierungslänge $n$ ist\\
$s_M(n)=\max \{s_M(w)|w\in\Sigma^n\}$
\end{Definition}

\begin{Definition}
Sei $f: \mathbb{N} \rightarrow \mathbb{N}$ eine Funktion.
\begin{itemize}
\item
$\textcolor{blue}{\textsf{DSPACE}(f)}$ ist die Menge aller Entscheidungsprobleme, die sich durch eine DTM $M$ mit Speicherbedarf $s_M = O(f)$ entscheiden lassen.
\item
$\textcolor{blue}{\textsf{NSPACE}(f)}$ ist die Menge aller Entscheidungsprobleme, die sich durch eine NTM $M$ mit Speicherbedarf $s_M = O(f)$ entscheiden lassen.
\end{itemize}
\end{Definition}

\begin{Definition}[Platzkomplexitätsklassen \textsf{PSPACE} und \textsf{NSPACE}]
\begin{equation*}
\textsf{PSPACE} := \bigcup_{k=0}^\infty \textsf{DSPACE}(n^k) \quad \textsf{NSPACE} := \bigcup_{k=0}^\infty \textsf{NSPACE}(n^k)
\end{equation*}
\end{Definition}

\begin{Satz}[Satz von Savitch]
$\textsf{PSPACE}=\textsf{NSPACE}$
\end{Satz}

\begin{Satz}
$\textsf{P}\subseteq\textsf{NP}\subseteq\textsf{PSPACE}\subseteq\textsf{EXPTIME}$
\end{Satz}

\section{Umgang mit schwierigen Problemen}
\subsection{\textcolor{blue}{Betrachtung von Spezialfällen}}
Manchmal sind nur spezielle Fälle eines schwierigen Problems praktisch relevant. Für diese kann es möglich sein, sie effizient zu lösen.
\begin{Beispiel}
\textsf{SUBSET SUM} ist für {\glqq}super-wachsende{\grqq} Eingaben polynomiell lösbar.
\end{Beispiel}
\subsection{\textcolor{blue}{Annäherungsverfahren}}
Man betrachtet die \textcolor{blue}{Optimierungsversion} des zugehörigen Entscheidungsproblems und probiert die Lösung zu approximieren.
\begin{Definition}
Ein \textcolor{blue}{$c$-Approximationsalgorithmus} $A$ (mit Güte $c > 1$) ist ein Algorithmus mit:
\begin{itemize}
\item
Die Laufzeit von $A$ ist polynomiell zur Eingabelänge.
\item
Die Ausgabe $v$ von $A$ zur Eingabe $w$ ist eine zulässige Lösung.
\item
$c=
\begin{cases}
\frac{v}{v^*}& \text{bei Minimierungsproblemen}\\
\frac{v^*}{v}& \text{bei Maximierungsproblemen}\\
\end{cases}$, wobei $v^*$ eine optimale Lösung ist.
\end{itemize}
\end{Definition}
\subsection{\textcolor{blue}{Parametrisierte Algorithmen}}
Komplexe Parameter des Problems werden von der Eingabe getrennt.

\subsection{\textcolor{blue}{Randomisierte Algorithmen}}
Ein randomisierter Algorithmus hat in seinem Ablauf Zugriff auf eine Quelle von Zufallszahlen.

\chapter{Formale Sprachen}
\textbf{Kernfrage: Wie können Sprachen beschrieben werden?}

\section{Grundbegriffe}

\begin{Definition}[Alphabete, Wörter, Sprachen]
\noindent
\begin{itemize}
\item
Ein \textcolor{blue}{Alphabet} $\Sigma$ ist eine nichtleere, endliche Menge.
\item
Die Elemente von $\Sigma$ heißen \textcolor{blue}{Zeichen} (Symbole, Buchstaben) des Alphabets.
\item
Ein \textcolor{blue}{Wort} $w$ über dem Alphabet $\Sigma$ ist eine endliche Folge von Zeichen aus $\Sigma$.
\item
Die \textcolor{blue}{Länge} $|w|$ des Wortes $w$ ist die Anzahl der Zeichen in $w$.
\item
Das \textcolor{blue}{leere Wort} $\varepsilon$ bezeichnet das Wort der Länge $0$.
\item
$\Sigma^*$ ist die Menge aller Wörter über $\Sigma$.
\item
Eine \textcolor{blue}{formale Sprache} über dem Alphabet $\Sigma$ ist eine Teilmenge von $\Sigma^*$.
\end{itemize}
\end{Definition}

\begin{Definition}[Grammatik]
Eine Grammatik ist ein 4-Tupel $G=(N,\Sigma,R,S)$ mit
\noindent
\begin{itemize}
\item
einem endlichem Alphabet $N$ von \textcolor{blue}{\textbf{N}ichtterminalen},
\item
einem endlichen Alphabet $\Sigma$ von \textcolor{blue}{Terminalen}, $N\cap \Sigma = \varnothing$,
\item
einer endlichen Menge $R \subseteq (N \cup \Sigma)^* N (N \cup \Sigma)^* \times (N \cup \Sigma)^*$ von (Produktions-) \textcolor{blue}{\textbf{R}egeln},
\item
und einem \textcolor{blue}{\textbf{S}tartsymbol} $S\in N$.
\end{itemize}
\end{Definition}

\begin{Definition}
Die von einer Grammatik $G=(N,\Sigma,R,S)$ \textcolor{blue}{erzeugte Sprache} ist $L(G)=\{w\in \Sigma^* \mid S \Rightarrow^* w\}$.
\end{Definition}

\begin{Definition}
Zwei Grammatiken $G_1=(N_1,\Sigma_1,R_1,S_1)$ und $G_2=(N_2,\Sigma_2,R_2,S_2)$ heißen \textcolor{blue}{äquivalent}, wenn $L(G_1)=L(G_2)$ gilt.
\end{Definition}

\begin{Satz}
$L\subseteq\Sigma^*$ ist aufzählbar $\Leftrightarrow$ Es gibt Grammatik $G=(N,\Sigma,R,S)$ mit $L = L(G)$.
\end{Satz}

\section{Chomsky Hierarchie}
\begin{Definition}[Typ 0: Unbeschränkte Grammatiken]
\noindent
\begin{itemize}
\item
Eine Grammatik $G=(N,\Sigma,R,S)$ heißt \textcolor{blue}{unbeschränkt}.
\item
Eine Sprache $L$ ist \textcolor{blue}{aufzählbar}, falls es eine unbeschränkte Grammatik $G$ gibt mit $L(G)=L$.
\end{itemize}
\end{Definition}

\begin{Definition}[Typ 1: Kontextsensitive Grammatiken]
\noindent
\begin{itemize}
\item
Eine Grammatik $G=(N,\Sigma,R,S)$ heißt \textcolor{blue}{kontextsensitiv}, wenn für jede Regel $u\rightarrow v$ in $R$ gilt: $|u| \leq |v|$, mit der Ausnahme $S \rightarrow \varepsilon$, falls das Startsymbol $S$ auf keiner rechten Seite einer Regel vorkommt.
\item
Eine Sprache $L$ heißt \textcolor{blue}{kontextsensitiv}, falls es eine kontextsensitive Grammatik $G$ gibt mit $L(G)=L$.
\end{itemize}
\end{Definition}

\begin{Satz}
Kontextsensitive Sprachen sind entscheidbar.
\end{Satz}

\begin{Definition}[Typ 2: Kontextfreie Grammatiken]
\noindent
\begin{itemize}
\item
Eine Grammatik $G=(N,\Sigma,R,S)$ heißt \textcolor{blue}{kontextfrei}, wenn für jede Regel $u\rightarrow v$ in $R$ gilt: $|u| \in N$.
\item
Eine Sprache $L$ heißt \textcolor{blue}{kontextfrei}, falls es eine kontextfreie Grammatik $G$ gibt mit $L(G)=L$.
\end{itemize}
\end{Definition}

\begin{Definition}[Typ 3: Reguläre Grammatiken]
\noindent
\begin{itemize}
\item
Eine Grammatik $G=(N,\Sigma,R,S)$ heißt \textcolor{blue}{regulär} (oder rechtslinear), wenn für jede Regel $u\rightarrow v$ in $R$ gilt: $|u| \in N$ und $v\in\{\varepsilon\}\cup\Sigma\cup\Sigma N$.
\item
Eine Sprache $L$ heißt \textcolor{blue}{regulär}, falls es eine reguläre Grammatik $G$ gibt mit $L(G)$.
\end{itemize}
\end{Definition}

\begin{Satz}[Chomsky-Hierarchie]
Typ 3 $\subset$ Typ 2 $\subset$ Typ 1 $\subset$ Typ 0
\end{Satz}

\section{Endliche Automaten}
\begin{Definition}[Endliche Automaten]
Ein \textcolor{blue}{nichtdeterministischer endlicher Automat} (NEA) ist ein $5$-Tupel $A=(Z,\Sigma,\delta,z_0,F)$ mit:
\begin{itemize}
\item
$Z$ endliche Zustandsmenge
\item
$z_0 \in Z$ \textcolor{blue}{Anfangszustand}
\item
$F \in Z$ Menge der akzeptierenden Zustände (\textcolor{blue}{Endzustände})
\item
$\Sigma$ endlichens \textcolor{blue}{Eingabealphabet}
\item
$\delta : Z \times \Sigma \rightarrow 2^Z$ \textcolor{blue}{Überführungsrelation}
\end{itemize}
Ist die Überführungsrelation eine Funktion, also $\delta : Z \times \Sigma \rightarrow Z$, so ist der endliche Automat \textcolor{blue}{deterministisch} (DEA).
\end{Definition}

\begin{Definition}[Sprache eines NEA]
Sei $A=(Z,\Sigma,\delta, z_0,F)$ ein NEA.
\begin{itemize}
\item
Ein \textcolor{blue}{Lauf} von $A$, gesteuert durch Eingabefolge $w=x_0 x_1 \ldots x_n \in \Sigma^*$ ist \textcolor{red}{eine} Folge von Zuständen $z_0$, $z_1$, $\ldots$, $z_{n+1}$ mit $z_{i+1}\textcolor{red}{\in} \delta(z_i,x_i)$, $0 \leq i \leq n$.\par
Ist $w=\varepsilon$, so besteht der Lauf nur aus dem Anfangszustand $z_0$.
\item
Die von $A$ \textcolor{blue}{akzeptierte Sprache} ist
\begin{flalign*}
L(A) = \{ w\in \Sigma^* \mid \,&\text{\textcolor{red}{es gibt einen} Lauf von $A$, gesteuert durch $w$,}&\\
&\text{der zu einem Endzustand führt}\}&
\end{flalign*}
\end{itemize}
\end{Definition}

\begin{Definition}[Sprache eines DEA]
Sei $A=(Z,\Sigma,\delta, z_0,F)$ ein DEA.
\begin{itemize}
\item
Ein \textcolor{blue}{Lauf} von $A$, gesteuert durch Eingabefolge $w=x_0 x_1 \ldots x_n \in \Sigma^*$ ist \textcolor{red}{die} Folge von Zuständen $z_0$, $z_1$, $\ldots$, $z_{n+1}$ mit $z_{i+1}\textcolor{red}{=} \delta(z_i,x_i)$, $0 \leq i \leq n$.\par
Ist $w=\varepsilon$, so besteht der Lauf nur aus dem Anfangszustand $z_0$.
\item
Die von $A$ \textcolor{blue}{akzeptierte Sprache} ist
\begin{flalign*}
L(A) = \{ w\in \Sigma^* \mid \,&\text{\textcolor{red}{der} Lauf von $A$, gesteuert durch $w$,}&\\
&\text{führt zu einem Endzustand}\}&
\end{flalign*}
\end{itemize}
\end{Definition}

\begin{Definition}
Zwei endliche Automaten sind \textcolor{blue}{äquivalent}, wenn sie die gleiche Sprache akzeptieren.
\end{Definition}

\begin{Satz}
Zu jedem NEA gibt es einen äquivalenten DEA.\par
Ist $A=(Z,\Sigma,\delta,z_0,F)$ ein NEA, dann ist der Potenzmengenautomat $A^\prime = (2^Z,\Sigma,\delta^\prime,\{z_0\},F^\prime)$ mit:
\begin{itemize}
\item[$\vartriangleright$]
$F^\prime=\{M\subseteq Z \mid M \cap F \neq \varnothing \}$
\item[$\vartriangleright$]
$\delta^\prime(M,x)=\bigcup\limits_{z\in M} \delta(z,x)$
\end{itemize}
ein DEA mit $L(A)=L(A^\prime)$.
\end{Satz}

\begin{Satz}
Zu jedem DEA $A$ gibt es eine reguläre Grammatik $G$ mit $L(G)=L(A)$.\par
Ist $A = (Z,\Sigma,\delta,z_0,F)$ ein DEA, dann ist $G = (Z,\Sigma,R,z_0)$ mit
\begin{itemize}
\item[$\vartriangleright$]
ist $z_0 \in F$, so ist $z_0 \rightarrow \varepsilon \in R$
\item[$\vartriangleright$]
ist $\delta(z,x)=z^\prime$, so ist $z \rightarrow xz^\prime \in R$\par
ist $z^\prime \in F$, so ist außerdem $z^\prime \rightarrow \varepsilon \in R$
\end{itemize}
eine reguläre Grammatik mit $L(G)=L(A)$.
\end{Satz}

\begin{Satz}
Zu jeder regulären Grammatik $G$ gibt es einen NEA $A$ mit ${L(A)=L(G)}$.
\end{Satz}

\section{Reguläre Ausdrücke}

\begin{Definition}[Syntax regulärer Ausdrücke]
Sei $\Sigma$ ein Alphabet.
\begin{enumerate}
\item
\textcolor{blue}{$\varnothing$} und \textcolor{blue}{$\varepsilon$} sind reguläre Ausdrücke.
\item
Für jedes $a\in \Sigma$ ist \textcolor{blue}{$a$} ein regulärer Ausdruck.
\item
Sind $x$ und $y$ reguläre Ausdrücke, so sind auch\par
\textcolor{blue}{$(x)+(y)$}, \textcolor{blue}{$(x)(y)$} und \textcolor{blue}{$(x)^*$} reguläre Ausdrücke.
\item
Weitere reguläre Ausdrücke gibt es nicht.
\end{enumerate}
\end{Definition}

\begin{Definition}[Semantik regulärer Ausdrücke]
Sei $x$ ein regulärer Ausdruck über $\Sigma$. Die von $x$ beschriebene Sprache $L(x)$ ist:
\begin{enumerate}
\item
\textcolor{blue}{$L(\varnothing) = \varnothing$} und \textcolor{blue}{$L(\varepsilon) = \{\varepsilon\}$}.
\item
Für jedes $a\in\Sigma$ ist \textcolor{blue}{$L(a) = \{a\}$}.
\item
\textcolor{blue}{$L(x+y)=L(x)\cup L(y)$}, \textcolor{blue}{$L(xy)=L(x)L(y)$} und \textcolor{blue}{$L(x^*)=L(x)^*$}.
\end{enumerate}
\end{Definition}

\begin{Definition}
Zwei reguläre Ausdrücke $x$, $y$ über $\Sigma$ heißen \textcolor{blue}{äquivalent}, wenn ${L(x)=L(y)}$ gilt, dass heißt wenn sie die gleiche Sprache beschreiben. Schreibweise: ${x \equiv y}$.
\end{Definition}

\begin{Satz}
Zu jedem regulären Ausdruck $x$ gibt es eine reguläre Grammatik $G$ mit ${L(G)=L(x)}$. 
\end{Satz}

\begin{Satz}
Zu jedem DEA $A$ gibt es einen regulären Ausdruck $r$ mit ${L(r)=L(A)}$.
\end{Satz}

\begin{Satz}
$L\subseteq \Sigma^*$ ist regulär genau dann, wenn $L$ aus den Sprachen $\varnothing$, $\{\varepsilon\}$ und $\{a\}$, $a\in\Sigma$, durch Vereinigung $\cup$, Konkatenation (Produkt) und Iteration $^*$ konstruiert werden kann.
\end{Satz}
\end{document}